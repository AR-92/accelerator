import logger from '../../../utils/logger.js';
import { serviceFactory } from '../../../services/serviceFactory.js';

// System Health API - Get metrics for AJAX requests
export const getSystemHealthMetrics = async (req, res) => {
  try {
    logger.info('API system health metrics requested');

    const systemHealthService = serviceFactory.getSystemHealthService();
    const systemMetrics = await systemHealthService.getSystemMetrics();

    // Generate some mock logs for the UI
    const logs = [
      {
        level: 'info',
        message: 'System metrics updated successfully',
        timestamp: new Date().toISOString(),
      },
      {
        level: 'info',
        message: 'Database connection verified',
        timestamp: new Date(Date.now() - 2 * 60 * 1000).toISOString(),
      },
      {
        level: 'warning',
        message: 'Memory usage above 60% threshold',
        timestamp: new Date(Date.now() - 10 * 60 * 1000).toISOString(),
      },
    ];

    res.json({
      success: true,
      systemMetrics,
      logs,
    });
  } catch (error) {
    logger.error('Error fetching system health metrics:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      systemMetrics: {
        dbConnected: false,
        memoryUsagePercent: 0,
        uptimeString: '0d 0h 0m',
        cpuUsage: 0,
        diskUsage: 0,
        totalTables: 0,
        totalRecords: 0,
        queriesPerMin: 0,
        responseTime: 0,
        activeConnections: 0,
      },
      logs: [],
    });
  }
};

// System Health API - Export report
export const exportSystemHealthReport = async (req, res) => {
  try {
    logger.info('System health report export requested');

    const systemHealthService = serviceFactory.getSystemHealthService();
    const systemMetrics = await systemHealthService.getSystemMetrics();

    // Generate a simple text report (in production, you'd generate PDF)
    const report = `
System Health Report - ${new Date().toLocaleString()}

SYSTEM METRICS:
- Database Status: ${systemMetrics.dbConnected ? 'Connected' : 'Disconnected'}
- Server Uptime: ${systemMetrics.uptimeString}
- Memory Usage: ${systemMetrics.memoryUsagePercent}%
- CPU Usage: ${systemMetrics.cpuUsage}%
- Disk Usage: ${systemMetrics.diskUsage}%

DATABASE METRICS:
- Total Tables: ${systemMetrics.totalTables}
- Total Records: ${systemMetrics.totalRecords}
- Queries/Min: ${systemMetrics.queriesPerMin}
- Active Connections: ${systemMetrics.activeConnections}
- Response Time: ${systemMetrics.responseTime}ms

Generated by Accelerator System Monitor
    `.trim();

    res.setHeader('Content-Type', 'text/plain');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="system-health-report-${new Date().toISOString().split('T')[0]}.txt"`
    );
    res.send(report);
  } catch (error) {
    logger.error('Error exporting system health report:', error);
    res.status(500).json({ success: false, error: error.message });
  }
};

// System Health API - Run database health check
export const runDatabaseHealthCheck = async (req, res) => {
  try {
    logger.info('Database health check requested');

    const results = [];

    // Check 1: Database connection
    try {
      const { data, error } = await databaseService.supabase
        .from('accounts')
        .select('count', { count: 'exact', head: true });

      results.push({
        check: 'Database Connection',
        status: error ? 'failed' : 'passed',
        message: error
          ? 'Failed to connect to database'
          : 'Successfully connected to database',
        details: error
          ? error.message
          : `Found ${data || 0} records in accounts table`,
      });
    } catch (error) {
      results.push({
        check: 'Database Connection',
        status: 'failed',
        message: 'Failed to connect to database',
        details: error.message,
      });
    }

    // Check 2: Table integrity
    const tables = [
      'accounts',
      'ideas',
      'projects',
      'users',
      'billing',
      'learning_content',
      'messages',
      'help_center',
      'corporate',
      'enterprises',
      'funding',
      'learning_analytics',
      'learning_categories',
      'learning_assessments',
      'packages',
      'project_collaborators',
      'collaborations',
      'content',
      'calendar',
      'financial_model',
      'business_model',
      'business_plan',
      'rewards',
      'votes',
      'todos',
      'notifications',
      'activity_logs',
    ];

    let accessibleTables = 0;
    let totalRecords = 0;

    for (const table of tables) {
      try {
        const { count, error } = await databaseService.supabase
          .from(table)
          .select('*', { count: 'exact', head: true });

        if (!error) {
          accessibleTables++;
          totalRecords += count || 0;
        }
      } catch (e) {
        // Table might not exist
      }
    }

    results.push({
      check: 'Table Accessibility',
      status: accessibleTables > 0 ? 'passed' : 'failed',
      message: `${accessibleTables} out of ${tables.length} tables accessible`,
      details: `Total records across accessible tables: ${totalRecords}`,
    });

    // Check 3: Performance - Query execution time
    try {
      const startTime = Date.now();
      const { data, error } = await databaseService.supabase
        .from('todos')
        .select('*')
        .limit(10);

      const executionTime = Date.now() - startTime;

      results.push({
        check: 'Query Performance',
        status: executionTime < 1000 ? 'passed' : 'warning',
        message: `Sample query executed in ${executionTime}ms`,
        details:
          executionTime < 1000
            ? 'Performance is good'
            : 'Query took longer than expected',
      });
    } catch (error) {
      results.push({
        check: 'Query Performance',
        status: 'failed',
        message: 'Failed to execute test query',
        details: error.message,
      });
    }

    // Check 4: Connection pool status (simulated)
    results.push({
      check: 'Connection Pool',
      status: 'passed',
      message: 'Connection pool operating normally',
      details: 'Active connections within normal range',
    });

    res.json({
      success: true,
      results,
    });
  } catch (error) {
    logger.error('Error running database health check:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      results: [
        {
          check: 'Health Check System',
          status: 'failed',
          message: 'Failed to run health checks',
          details: error.message,
        },
      ],
    });
  }
};

// System Health API - Clear cache
export const clearCache = async (req, res) => {
  try {
    logger.info('Cache clear requested');

    // Clear Node.js require cache (for development)
    if (process.env.NODE_ENV === 'development') {
      Object.keys(require.cache).forEach((key) => {
        if (key.includes('node_modules')) return; // Skip node_modules
        delete require.cache[key];
      });
    }

    // Clear any application-level caches (if they exist)
    // This is a placeholder for future cache implementations

    res.json({
      success: true,
      message: 'Cache cleared successfully',
      details:
        process.env.NODE_ENV === 'development'
          ? 'Require cache cleared'
          : 'No cache to clear in production',
    });
  } catch (error) {
    logger.error('Error clearing cache:', error);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
};

// System Health API - Run diagnostics
export const runDiagnostics = async (req, res) => {
  try {
    logger.info('System diagnostics requested');

    const results = [];
    const startTime = Date.now();

    // Test 1: Network connectivity
    try {
      const dns = await import('dns/promises');
      await dns.lookup('google.com');
      results.push({
        test: 'Network Connectivity',
        status: 'passed',
        message: 'External network connectivity verified',
        duration: Date.now() - startTime,
      });
    } catch (error) {
      results.push({
        test: 'Network Connectivity',
        status: 'failed',
        message: 'Failed to resolve external host',
        duration: Date.now() - startTime,
      });
    }

    // Test 2: File system access
    try {
      const fs = await import('fs/promises');
      await fs.access(process.cwd());
      results.push({
        test: 'File System Access',
        status: 'passed',
        message: 'File system access verified',
        duration: Date.now() - startTime,
      });
    } catch (error) {
      results.push({
        test: 'File System Access',
        status: 'failed',
        message: 'File system access failed',
        duration: Date.now() - startTime,
      });
    }

    // Test 3: Memory usage check
    const memUsage = process.memoryUsage();
    const memUsageMB = memUsage.heapUsed / 1024 / 1024;
    const memStatus =
      memUsageMB < 500 ? 'passed' : memUsageMB < 1000 ? 'warning' : 'failed';

    results.push({
      test: 'Memory Usage',
      status: memStatus,
      message: `Current heap usage: ${memUsageMB.toFixed(1)}MB`,
      duration: Date.now() - startTime,
    });

    // Test 4: CPU load check
    const os = await import('os');
    const loadAvg = os.loadavg()[0];
    const cpuStatus =
      loadAvg < 2 ? 'passed' : loadAvg < 5 ? 'warning' : 'failed';

    results.push({
      test: 'CPU Load',
      status: cpuStatus,
      message: `Current load average: ${loadAvg.toFixed(2)}`,
      duration: Date.now() - startTime,
    });

    // Test 5: Database connectivity
    try {
      const { data, error } = await databaseService.supabase
        .from('todos')
        .select('count', { count: 'exact', head: true });

      results.push({
        test: 'Database Connectivity',
        status: error ? 'failed' : 'passed',
        message: error
          ? 'Database connection failed'
          : 'Database connection successful',
        duration: Date.now() - startTime,
      });
    } catch (error) {
      results.push({
        test: 'Database Connectivity',
        status: 'failed',
        message: 'Database connection failed',
        duration: Date.now() - startTime,
      });
    }

    // Test 6: Application responsiveness
    results.push({
      test: 'Application Responsiveness',
      status: 'passed',
      message: 'Application is responding normally',
      duration: Date.now() - startTime,
    });

    res.json({
      success: true,
      results,
      totalDuration: Date.now() - startTime,
    });
  } catch (error) {
    logger.error('Error running diagnostics:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      results: [
        {
          test: 'Diagnostics System',
          status: 'failed',
          message: 'Failed to run diagnostics',
          duration: 0,
        },
      ],
    });
  }
};

// Route setup function
export default function systemHealthRoutes(app) {
  app.get('/api/admin/system-health/metrics', getSystemHealthMetrics);
  app.get('/api/admin/system-health/export', exportSystemHealthReport);
  app.post('/api/admin/system-health/db-health-check', runDatabaseHealthCheck);
  app.post('/api/admin/system-health/clear-cache', clearCache);
  app.post('/api/admin/system-health/run-diagnostics', runDiagnostics);
}
